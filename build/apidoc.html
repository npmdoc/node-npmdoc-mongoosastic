<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mongoosastic/mongoosastic#readme"

    >mongoosastic (v4.3.0)</a>
</h1>
<h4>A mongoose plugin that indexes models into elastic search</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoosastic">module mongoosastic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoosastic.mongoosastic">
            function <span class="apidocSignatureSpan"></span>mongoosastic
            <span class="apidocSignatureSpan">(schema, pluginOpts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoosastic.mapping_generator">
            function <span class="apidocSignatureSpan">mongoosastic.</span>mapping_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoosastic.</span>mapping_generator.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoosastic.mapping_generator">module mongoosastic.mapping_generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoosastic.mapping_generator.mapping_generator">
            function <span class="apidocSignatureSpan">mongoosastic.</span>mapping_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoosastic.mapping_generator.prototype">module mongoosastic.mapping_generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoosastic.mapping_generator.prototype.generateMapping">
            function <span class="apidocSignatureSpan">mongoosastic.mapping_generator.prototype.</span>generateMapping
            <span class="apidocSignatureSpan">(schema, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoosastic" id="apidoc.module.mongoosastic">module mongoosastic</a></h1>


    <h2>
        <a href="#apidoc.element.mongoosastic.mongoosastic" id="apidoc.element.mongoosastic.mongoosastic">
        function <span class="apidocSignatureSpan"></span>mongoosastic
        <span class="apidocSignatureSpan">(schema, pluginOpts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mongoosastic(schema, pluginOpts) {
  let options = pluginOpts || {}

  let bulkTimeout
  let bulkBuffer = []
  let esClient
  let populate = options &#x26;&#x26; options.populate
  let mapping = getMapping(schema)

  let indexName = options &#x26;&#x26; options.index
  let typeName = options &#x26;&#x26; options.type
  let alwaysHydrate = options &#x26;&#x26; options.hydrate
  let defaultHydrateOptions = options &#x26;&#x26; options.hydrateOptions
  let bulk = options &#x26;&#x26; options.bulk
  let filter = options &#x26;&#x26; options.filter
  let transform = options &#x26;&#x26; options.transform
  let routing = options &#x26;&#x26; options.routing

  let customProperties = options &#x26;&#x26; options.customProperties
  let customSerialize = options &#x26;&#x26; options.customSerialize
  let indexAutomatically = !(options &#x26;&#x26; options.indexAutomatically === false)
  let saveOnSynchronize = !(options &#x26;&#x26; options.saveOnSynchronize === false)

  if (options.esClient) {
    esClient = options.esClient
  } else {
    esClient = createEsClient(options)
  }

  function setIndexNameIfUnset (model) {
    const modelName = model.toLowerCase()
    if (!indexName) {
      indexName = `${modelName}s`
    }

    if (!typeName) {
      typeName = modelName
    }
  }

  function postSave (doc) {
    let _doc
    function onIndex (err, res) {
      if (!filter || !filter(doc)) {
        doc.emit(&#x27;es-indexed&#x27;, err, res)
      } else {
        doc.emit(&#x27;es-filtered&#x27;, err, res)
      }
    }

    if (doc) {
      _doc = new doc.constructor(doc)
      if (populate &#x26;&#x26; populate.length) {
        populate.forEach(populateOpts =&#x3e; {
          _doc.populate(populateOpts)
        })
        _doc.execPopulate().then(popDoc =&#x3e; {
          popDoc.index(onIndex)
        }).catch(onIndex)
      } else {
        _doc.index(onIndex)
      }
    }
  }

  function clearBulkTimeout () {
    clearTimeout(bulkTimeout)
    bulkTimeout = undefined
  }

  function bulkAdd (instruction) {
    bulkBuffer.push(instruction)

    // Return because we need the doc being indexed
    // Before we start inserting
    if (instruction.index &#x26;&#x26; instruction.index._index) {
      return
    }

    if (bulkBuffer.length &#x3e;= ((bulk &#x26;&#x26; bulk.size) || 1000)) {
      schema.statics.flush()
      clearBulkTimeout()
    } else if (bulkTimeout === undefined) {
      bulkTimeout = setTimeout(() =&#x3e; {
        schema.statics.flush()
        clearBulkTimeout()
      }, (bulk &#x26;&#x26; bulk.delay) || 1000)
    }
  }

  function bulkDelete (opts, cb) {
    bulkAdd({
      delete: {
        _index: opts.index || indexName,
        _type: opts.type || typeName,
        _id: opts.model._id.toString(),
        _routing: opts.routing
      }
    })
    cb()
  }

  function bulkIndex (opts) {
    bulkAdd({
      index: {
        _index: opts.index || indexName,
        _type: opts.type || typeName,
        _id: opts._id.toString(),
        _routing: opts.routing
      }
    })
    bulkAdd(opts.model)
  }

<span class="apidocCodeCommentSpan">  /**
   * ElasticSearch Client
   */
</span>  schema.statics.esClient = esClient

  /**
   * Create the mapping. Takes an optional settings parameter
   * and a callback that will be called once the mapping is created

   * @param settings Object (optional)
   * @param cb Function
   */
  schema.statics.createMapping = function createMapping (inSettings, inCb) {
    let cb = inCb
    let settings = inSettings
    if (arguments.length &#x3c; 2) {
      cb = inSettings || nop
      settings = undefined
    }

    setIndexNameIfUnset(this.modelName)

    createMappingIfNotPresent({
      client: esClient,
      indexName: indexName,
      typeName: typeName,
      schema: schema,
      settings: settings,
      properties: customProperties
    }, cb)
  }

  /**
   * @param options  Object (optional)
   * @param cb Function
   */
  schema.methods.index = function schemaIndex (inOpts, inCb) {
    let index
    let type
    let serialModel
    let cb = inCb
    let opts = inOpts
    let _serialize = serialize

    if (arguments.length &#x3c; 2) {
      cb = inOpts || nop
      opts = {}
    }

    if (filter &#x26;&#x26; filter(this)) {
      return this.unIndex(cb)
    }

    if (typeof customSerialize === &#x27;function&#x27;) {
      _serial ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoosastic.mapping_generator" id="apidoc.element.mongoosastic.mapping_generator">
        function <span class="apidocSignatureSpan">mongoosastic.</span>mapping_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Generator() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoosastic.mapping_generator" id="apidoc.module.mongoosastic.mapping_generator">module mongoosastic.mapping_generator</a></h1>


    <h2>
        <a href="#apidoc.element.mongoosastic.mapping_generator.mapping_generator" id="apidoc.element.mongoosastic.mapping_generator.mapping_generator">
        function <span class="apidocSignatureSpan">mongoosastic.</span>mapping_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Generator() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoosastic.mapping_generator.prototype" id="apidoc.module.mongoosastic.mapping_generator.prototype">module mongoosastic.mapping_generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoosastic.mapping_generator.prototype.generateMapping" id="apidoc.element.mongoosastic.mapping_generator.prototype.generateMapping">
        function <span class="apidocSignatureSpan">mongoosastic.mapping_generator.prototype.</span>generateMapping
        <span class="apidocSignatureSpan">(schema, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateMapping(schema, cb) {
  const cleanTree = getCleanTree(schema.tree, schema.paths, &#x27;&#x27;)
  delete cleanTree[schema.get(&#x27;versionKey&#x27;)]
  let mapping = getMapping(cleanTree, &#x27;&#x27;)
  cb(null, {
    properties: mapping
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function isStringArray (arr) {
return arr.filter &#x26;&#x26; arr.length === (arr.filter(item =&#x3e; typeof item === &#x27;string&#x27;)).length
}

function getMapping (schema) {
let retMapping = {}
generator.<span class="apidocCodeKeywordSpan">generateMapping</span>(schema, (err, mapping) =&#x3e; {
  if (err) {
    // no handling needed
  }
  retMapping = mapping
})

return retMapping
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
